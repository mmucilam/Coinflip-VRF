// SPDX-License-Identifier: MIT
pragma solidity ^0.8.23;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {VRFConsumerBase} from "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";

contract Coinflip is Ownable, VRFConsumerBase {
    // A map of the player and their corresponding random number request
    mapping(address => uint256) public playerRequestID;
    // A map that stores the users coinflip guess
    mapping(address => uint8) public bets;

    // LINK token contract address
    address private linkAddr = 0x779877A7B0D9E8603169DdbD7836e478b4624789;
    // VRF contract address
    address private vrfContractAddr = 0x94778BD3f91C422fdf8451deBB444847b0524Fc9;

    // Callback function signature
    bytes32 private constant CALLBACK_SELECTOR = keccak256("fulfillRandomWords(uint256,uint256[])");

    constructor()
        Ownable(msg.sender)
        VRFConsumerBase(vrfContractAddr, linkAddr)
    {}

    ///@dev we no longer use the seed, instead each coinflip should spawn its own VRF instance
    ///@notice This programming pattern is a factory model - a contract creating other contracts 
    constructor() Ownable(msg.sender) {}

    ///@notice Fund the VRF instance with **2** LINK tokens.
    ///@return A boolean of whether funding the VRF instance with link tokens was successful or not
    function fundOracle() external returns(bool){
        // Transfer 2 LINK tokens to the VRF contract address
        require(LINK.transfer(address(this), 2 ether), "Insufficient LINK tokens");
        return true;
    }

    ///@notice user guess only ONE flip either a 1 or a 0.
    ///@param Guess uint8 which is required to be 1 or 0
    function userInput(uint8 Guess) external {
        // Ensure that the guess is either 0 or 1
        require(Guess == 0 || Guess == 1, "Invalid guess");
        // Store the user's guess
        bets[msg.sender] = Guess;
        // Fire off a request to the VRF instance
        requestRandomness(0, 0, 1);
    }

    ///@notice due to the fact that a blockchain does not deliver data instantaneously, in fact quite slowly under congestion, allow
    ///        users to check the status of their request.
    ///@return a boolean of whether the request has been fulfilled or not
    function checkStatus() external view returns(bool){
        // Get the request ID of the current user
        uint256 requestId = playerRequestID[msg.sender];
        // Check if the request has been fulfilled
        // Implementation of this function depends on your contract design
    }

    ///@notice once the request is fulfilled, return the random result and check if user won
    ///@return a boolean of whether the user won or not based on their input
    function determineFlip() external view returns(bool){
        // Get the request ID of the current user
        uint256 requestId = playerRequestID[msg.sender];
        // Get the random words generated by the VRF instance
        // Implementation of this function depends on your contract design
    }

    // Callback function to receive the random number from the VRF coordinator
    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) public {
        // Store the request ID
        playerRequestID[msg.sender] = requestId;
        // Implementation of this function depends on your contract design
    }

    // Override the _fulfillRandomness function from VRFConsumerBase
    function _fulfillRandomness(uint256 requestId, uint256 randomness) internal override {
        // Process the randomness (optional)
        // Implementation of this function depends on your contract design
    }
}
